package main

import (
	"flag"
	"net/http"
	"os"
	"syscall"
	"time"

	"github.com/BurntSushi/toml"
	"github.com/op/go-logging"
	"github.com/pressly/gohttpware/auth"
	"github.com/pressly/gohttpware/route"
	"github.com/pressly/qmd"
	"github.com/zenazn/goji/graceful"
	"github.com/zenazn/goji/web"
	"github.com/zenazn/goji/web/middleware"
)

var (
	flagSet = flag.NewFlagSet("qmd-server", flag.ExitOnError)

	config = flagSet.String("config", "", "path to config file")

	// Basic Options
	name    = flagSet.String("name", "", "name of the server, autogenerated if none given")
	ttl     = flagSet.Duration("ttl", 5*time.Minute, "max time before request times out")
	address = flagSet.String("address", "0.0.0.0:8484", "<addr>:<port> to listen and respond on for HTTP clients")
	dbAddr  = flagSet.String("db-address", "0.0.0.0:6379", "<addr>:<port> to database server")

	// Authentication Options
	disableAuth = flagSet.Bool("disable-auth", false, "disable basic authentication")
	user        = flagSet.String("user", "", "basic auth username")
	pass        = flagSet.String("pass", "", "basic auth password")

	// Queue Options
	hostNSQD     = flagSet.String("host-nsqd", "0.0.0.0:4150", "<addr>:<port> to local NSQD node")
	nsqdAddrs    = qmd.StringFlagArray{}
	lookupdAddrs = qmd.StringFlagArray{}
	adminAddr    = flagSet.String("nsqadmin-address", "0.0.0.0:4171", "<addr>:<port> to nsqadmin node")

	// Logging Options
	logLevel    = flagSet.String("log-level", "INFO", "level of logging") // DEBUG > INFO > NOTICE > WARNING > ERROR > CRITICAL
	logBackends = qmd.StringFlagArray{}                                   // "STDOUT", "syslog", or "/file/path"

	log = logging.MustGetLogger("qmd")
)

func init() {
	flagSet.Var(&nsqdAddrs, "nsqd-addresses", "nsqd address for consumption (may be given multiple times)")
	flagSet.Var(&lookupdAddrs, "lookupd-addresses", "lookupd address for consumption, takes precedence over nsqd (may be given multiple times)")
	flagSet.Var(&logBackends, "log-backends", "log output location, defaults to STDOUT (may be given multiple times)")
}

func main() {
	var err error

	flagSet.Parse(os.Args[1:])

	var sc qmd.ServerConfig
	if *config != "" {
		// Use toml file settings
		if _, err := toml.DecodeFile(*config, &sc); err != nil {
			log.Error(err.Error())
			log.Fatal("Couldn't parse config file at", *config)
		}
	} else {
		// Use flag settings
		sc.Name = *name
		sc.TTL = *ttl
		sc.ListenOnAddr = *address
		sc.DBAddr = *dbAddr
		sc.DisableAuth = *disableAuth
		sc.Username = *user
		sc.Password = *pass
		sc.Queue = &qmd.QueueConfig{
			HostNSQDAddr: *hostNSQD,
			NSQDAddrs:    lookupdAddrs,
			LookupdAddrs: lookupdAddrs,
		}
		sc.AdminAddr = *adminAddr
		sc.Logging = &qmd.LoggingConfig{
			LogLevel:    *logLevel,
			LogBackends: logBackends,
		}
	}
	if err = sc.Clean(); err != nil {
		log.Fatal(err.Error())
	}

	// QMD server
	server, err := qmd.NewServer(&sc)
	if err != nil {
		log.Fatalf("Server couldn't be created: %s", err.Error())
	}

	// Web server
	w := web.New()

	// Middleware
	w.Use(middleware.Logger)
	w.Use(middleware.Recoverer)
	w.Use(route.Heartbeat("/ping"))
	if !*disableAuth {
		ra := auth.RedisAuth{
			Address:  *dbAddr,
			TTL:      900,
			Limit:    7,
			Username: sc.Username,
			Password: sc.Password,
		}
		ra.Connect()
		w.Use(ra.Handler())
	}
	w.Use(route.AllowSlash)
	w.Use(func(c *web.C, h http.Handler) http.Handler {
		handler := func(w http.ResponseWriter, r *http.Request) {
			if err == nil {
				if c.Env == nil {
					c.Env = make(map[string]interface{})
				}
				c.Env["server"] = server
				c.Env["adminAddr"] = sc.AdminAddr
			}
			h.ServeHTTP(w, r)
		}
		return http.HandlerFunc(handler)
	})

	// Endpoints
	w.Put("/scripts", reloadScripts)
	w.Post("/scripts/:name", runScript)
	w.Get("/scripts/:name/logs", getAllLogs)
	w.Get("/scripts/:name/logs/:id", getLog)
	w.Handle("/*", adminProxy)

	graceful.PreHook(func() {
		server.Exit()
	})
	graceful.AddSignal(syscall.SIGINT, syscall.SIGTERM)

	err = server.Run()
	if err != nil {
		log.Fatalf("Can't start server: %s", err.Error())
	}
	err = graceful.ListenAndServe(sc.ListenOnAddr, w)
	if err != nil {
		log.Fatal(err.Error())
	}
	graceful.Wait()
}
